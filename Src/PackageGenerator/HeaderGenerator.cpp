//
// Created by arthur on 09/12/2024.
//

#include <algorithm>
#include <format>

#include "Concerto/PackageGenerator/HeaderGenerator.hpp"


namespace cct
{
	bool HeaderGenerator::Generate(const Package& package)
	{
		std::string upperPackageName(package.name);
		std::ranges::transform(upperPackageName, upperPackageName.begin(), [](char c)
			{
				return std::toupper(c);
			});
		std::string api = upperPackageName + "_API";
		Write("//This file was automatically generated, do not edit\n");
		Write("#pragma once");
		Write("#include <string_view>");
		Write("#include <Concerto/Reflection/Defines.hpp>");
		NewLine();
		Write("#include <Concerto/Reflection/Class.hpp>");
		Write("#include <Concerto/Reflection/Object.hpp>");
		Write("#include <Concerto/Reflection/MemberVariable.hpp>");
		Write("#include <Concerto/Reflection/Method.hpp>");
		Write("#include <Concerto/Reflection/Package.hpp>");
		NewLine();
		Write("#ifdef {}PACKAGE_BUILD", upperPackageName);
		Write("#define {}PACKAGE_API CCT_EXPORT", upperPackageName);
		Write("#else");
		Write("#define {}PACKAGE_API CCT_IMPORT\n", upperPackageName);
		Write("#endif");
		NewLine();
		for (auto& include : package.includes)
		{
			if (include.isPublic)
				Write("#include <{}>", include.file);
		}

		for (auto& enum_ : package.enums)
			GenerateEnum(enum_, api);

		NewLine();

		for (auto& klass : package.classes)
		{
			GenerateClass(klass, api);
			NewLine();
		}

		NewLine();

		for (auto& ns : package.namepsaces)
			GenerateNamespace(ns, api);

		return true;
	}

	void HeaderGenerator::GenerateNamespace(const Namespace& ns, const std::string& api)
	{
		for (auto& nestedNamespace : ns.namespaces)
			GenerateNamespace(nestedNamespace, api);
		Write("namespace {}", ns.name);
		EnterScope();
		for (auto& enum_ : ns.enums)
			GenerateEnum(enum_, api);
		NewLine();
		for (auto& klass : ns.classes)
			GenerateClass(klass, api);
		LeaveScope();
	}

	void HeaderGenerator::GenerateClass(const Class& klass, const std::string& api)
	{
		if (!klass.autoGenerated)
			return;
		if (klass.base.empty())
			Write("class {} {}", api, klass.name);
		else
			Write("class {} {} : public {}", api, klass.name, klass.base);
		EnterScope();
		{
			Write("public:");
			for (const auto& member : klass.members)
			{
				Write("const {}& Get{}() const", member.type, Capitalize(member.name));
				EnterScope();
				Write("return _{};", member.name);
				LeaveScope();
				Write("{}& Get{}()", member.type, Capitalize(member.name));
				EnterScope();
				Write("return _{};", member.name);
				LeaveScope();
			}
			NewLine();
			Write("CCT_OBJECT({})", klass.name);
			NewLine();
			Write("private:");
			for (const auto& member : klass.members)
			{
				Write("{} _{}", member.type, member.name);
			}
		}
		LeaveScope();
	}

	void HeaderGenerator::GenerateEnum(const Enum& enum_, const std::string& api)
	{
		Write("enum class {} : {}", enum_.name, enum_.base);
		EnterScope();
		for (auto& elem : enum_.elements)
			Write("{} = {},", elem.name, elem.value);
		LeaveScope();
		NewLine();
		Write("{} {}ToString({} value);", api, Capitalize(enum_.name), enum_.name);
		Write("{} {}FromString(std::string_view str);", api, Capitalize(enum_.name));
	}
}
